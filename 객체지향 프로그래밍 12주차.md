# 프로그램 코드와 설명

## 1. 해당 코드는 vector컨테이너의의 요소를 sort함수를 사용하여 정렬하는 코드이다. 정렬이 제대로 되는지 확인을 위해 stdlib.h라이브러리를 추가하여 random요소를 추가했다.

```cpp
// 2025 - 11 - 17.cpp : 이 파일에는 'main' 함수가 포함됩니다.거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>
#include <vector>
#include <algorithm> // sort
#include <stdlib.h> // random
#include <time.h> // time

#define COUNT 5

using namespace std;

void PrintVector(vector<int> vect) {
    vector<int>::iterator it;

    it = vect.begin();

    while (it != vect.end()) {
        cout << *it << "\n";
        it++;
    }
}

int main()
{
    vector<int> vect;

    cout << "vect.size: " << vect.size() << "\n";
    // 현재시간을 시드로 사용하여 항상 다른 난수가 생성되도록 
    srand(time(NULL));

    for (int i = 0; i < COUNT; i++) {
        vect.push_back((rand() % 50) + 1);
    }

    PrintVector(vect);

    cout << "sort함수 사용 " << endl;

    // sort함수 사용 
    sort(vect.begin(), vect.end());

    PrintVector(vect);
}
```
결과: 
프로젝트를 실행할 때마다 랜덤된 숫자 5개가 vector에 들어가고 sort를 통해 정렬되어 printVector를 통해 출력된다.


## 2. 해당 코드는 Vector를 파라미터로 받아보는 예제이다. 

```cpp
// #include <iostream>
#include <vector>
using namespace std;
#define COUNT 10

void push_back(vector<int> vect, int val) {

    vector<int>::iterator it;

    vect.push_back(val);
    it = vect.begin();
    cout << *it << "\n";
    it++;
}

int main(int argc, char const* argv[])
{
   vector <int> v1;

    for (int i = 0; i < COUNT; i++) {
        push_back(v1, i);
    }
}
```
결과:
0
1
2
3
4
5
6
7
8
9

-> vector는 템플릿클래스(여러 자료형에도 일반화된 기능을 가지는 정의 자료형) 로써 자료형처럼 파라미터로 주고 받을 수 있다.


## 3. 해당 코드는  Vector가 템플릿클래스라는 개념을 통해 들어갈 요소의 자료형을 구조체 타입으로 선언하고 함수를 사용할 때 어떤 포멧을 가져야 하는지 확인 할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // sort

using namespace std;
#define COUNT 10

struct Student {
    int iID;
    int iScore;
};

void PrintVector(vector<Student> vect) {
    vector<Student>::iterator it;

    it = vect.begin();

    while (it != vect.end()) {
        cout << "ID:    " << (*it).iID << endl;
        cout << "Score: " << (*it).iScore << "\n\n";
        // it -> iID형태로 사용가능
        it++;
    }
}

int main(int argc, char const* argv[])
{
    // 여러가지 자료형을 저장할 수 있다.
    vector <Student> svect = { {1, 50}, {3, 40}, {5, 80} };

    // sort함수 사용 3번째 파라미터: 비교가 참이되는 조건을 넣어야함
    // [] () {} -> 어나니머스함수 재사용이 되지않는 함수를 사용
    
    // 점수별로 정렬
    //sort(svect.begin(), svect.end(), [](const Student& a, const Student& b) {return a.iScore < b.iScore; });

    // 학번으로 정렬
    sort(svect.begin(), svect.end(), [](const Student& a, const Student& b) {return a.iID < b.iID; });

    PrintVector(svect);
}


```
ID:    1
Score: 50

ID:    3
Score: 40

ID:    5
Score: 80

-> 여러 멤버변수를 가진 구조체를 Vector에 저장하고, sort로 순위를 매길 시, 어떤 멤버변수의 기준으로 순위를 매길지 명시해줘야 한다. 어나니머스 함수를 통해 우선순위를 명시해주어, sort가 어떤 기준을 가질지 해석하게 한다.
  

## 4. 해당 코드는  find함수를 통해 원하는 문자열이 포함된 vector요소의 주소값을 알 수 있다.

```cpp
// 2025 - 11 - 17.cpp : 이 파일에는 'main' 함수가 포함됩니다.거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>
#include <vector>
#include <algorithm> // sort
#include <stdlib.h> // random
#include <time.h> // time

#define COUNT 5

using namespace std;

void PrintVector(vector<int> vect) {
    vector<int>::iterator it;

    it = vect.begin();

    while (it != vect.end()) {
        cout << *it << "\n";
        it++;
    }
}

int main()
{
    vector<int> vect;

    cout << "vect.size: " << vect.size() << "\n";
    // 현재시간을 시드로 사용하여 항상 다른 난수가 생성되도록 
    srand(time(NULL));

    for (int i = 0; i < COUNT; i++) {
        vect.push_back(i);
    }

    PrintVector(vect);

    // find함수 사용 
    vector<int>::iterator it = find(vect.begin(), vect.end(), 4);

    cout << "find함수가 찾아낸 포인터의 주소 값: " << &(*it) << endl;
    cout << "find함수가 찾아낸 포인터의 실제 값: " << *it << endl;

    cout << "vector의 마지막 값 주소: " << &vect.back() << endl;
    cout << "vector의 마지막 값: " << vect.back() << endl;
    //sort(vect.begin(), vect.end());
}
```

결과:
vect.size: 0
0
1
2
3
4
find함수가 찾아낸 포인터의 주소 값: 0000020B1E4D52A0
find함수가 찾아낸 포인터의 실제 값: 4
vector의 마지막 값 주소: 0000020B1E4D52A0
vector의 마지막 값: 4

-> 결과를 통해 find사용시 반복자는 찾으려고 하는 값을 가리키는 포인터가 된다. &(*it)를 통해 포인터가 실제 가리키는 값의 메모리주소와 vector의 마지막 값의 주소가 동일하다. (find로 4를 찾고 4는 vector의 마지막 값이다.)