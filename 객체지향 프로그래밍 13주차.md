# 프로그램 코드와 설명

# STL LABS

## 1. 해당 코드는 vector컨테이너의를 함수의 파라미터로 넘기는 예를 확인할 수 있다. 함수에 요소를 추가하는 기능을 추가하고, 호출하면서 size와 capacity를 확인한다.

```cpp
// 다음과 같이 int형 vector 클래스의 객체를 선언하고 
// 객체에 새로운 데이터를 push_back() 을 여러번 호출하도록 코드를 수정하라. 
// push_back() 함수를 호출할 때 마다 객체에 대해 
// size와 capacity를 구해서 값의 변화를 분석하라

#include <iostream>
#include <vector>
using namespace std;

#define COUNT 10

void push_back(vector<int> &vect) {
	vect.push_back(10);

	cout << "size(vect)     : " << size(vect) << endl;
	cout << "vect.capacity(): " << vect.capacity() << "\n\n";
}

int main(int argc, char const* argv[])
{
	vector <int> v1;

	for (int i = 0; i < COUNT; i++) {
		push_back(v1);
	}
}
```
결과: 
size(vect)     : 1
vect.capacity(): 1

size(vect)     : 2
vect.capacity(): 2

size(vect)     : 3
vect.capacity(): 3

size(vect)     : 4
vect.capacity(): 4

size(vect)     : 5
vect.capacity(): 6

size(vect)     : 6
vect.capacity(): 6

size(vect)     : 7
vect.capacity(): 9

size(vect)     : 8
vect.capacity(): 9

size(vect)     : 9
vect.capacity(): 9

size(vect)     : 10
vect.capacity(): 13

-> Size는 Vector에 들어있는 요소의 갯수를 출력하고, capacity는 메모리가 할당된 값을 알려준다.
capacity가 각 요소가 추가될 떄 마다 메모리 용량을 늘리면 비효율적이고 느리기 때문에, 모자랄 때 한번에 크게 메모리 크기를 재할당한다.



## 2. 해당 코드는 Vector의 요소의 변화를 통해 assign함수의 기능을 확인할 수 있다.

```cpp
// 클래스 템플릿 vector를 사용한 프로그램이다. 
// 프로그램 수행 결과를 예측하고 실행 결과의 비교하고 vector 분석하라.

#include <vector>
#include <iostream>
using namespace std;
int main()
{
    vector<int> v1, v2, v3;

    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(30);
    v1.push_back(40);
    v1.push_back(50);

    cout << "v1 = ";
    for (auto& v : v1) {
        cout << v << " ";
    }
    cout << endl;

    v2.assign(v1.begin(), v1.end());
    cout << "v2 = ";
    for (auto& v : v2) {
        cout << v << " ";
    }
    cout << endl;

    v3.assign(3, 6);
    cout << "v3 = ";
    for (auto& v : v3) {
        cout << v << " ";
    }
    cout << endl;

    v3.assign({ 5, 6, 7 });
    for (auto& v : v3) {
        cout << v << " ";
    }
    cout << endl;

    int& i = v1.at(0);

    cout << "v1 첫 번째 원소의 값:  " << i << endl;

    if (v1 == v2) cout << "v1과 v2는 같다." << endl;
    else cout << "v1과 v2는 다르다" << endl;

    i = 80;
    const int& j = v1.at(0);

    cout << "값을 변경 후 v1 첫 번째 원소의 값:  " << j << endl;

    if (v1 == v2) cout << "v1과 v2는 같다." << endl;
    else cout << "v1과 v2는 다르다" << endl;
}
```
결과:
v1 = 10 20 30 40 50
v2 = 10 20 30 40 50
v3 = 6 6 6
5 6 7
v1 첫 번째 원소의 값:  10
v1과 v2는 같다.
값을 변경 후 v1 첫 번째 원소의 값:  80
v1과 v2는 다르다


v2.assign(v1.begin(), v1.end());
-> assign 함수를 통해 v2의 요소를 v1에 있는 요소로 똑같이 복사한다.

v3.assign(3, 6);
-> v3에 6을 3개 추가한다.

v3.assign({ 5, 6, 7 });
-> v3의 리스트 요소를 {5, 6, 7} 로 갈아엎는다.

int& i = v1.at(0);
-> i는 v1 첫번째 원소의 별명변수이다.

i = 80;
-> i를 80으로 변경시 별명변수의 값을 바꾸기 때문에 v1에 1번째 요소의 값이 바뀐다.




## 3. 해당 코드는  사각형을 표현한느 클래스를 정의하고 vector저장하는 코드이다.

```cpp
// 사각형을 표현하는 클래스를 정의하고 클래스를 
// vector 를 이용하여 저쟝하고 처리하는 프로그램을 작성하라.

#include <iostream>
#include <string>
#include <Vector>
using namespace std;

struct Quadrilateral {
    string sName; // 사각형 이름
    int iWidth; // 가로
    int iHeight; // 세로
};

// 요소를 추가하는 함수
void push_back(vector<Quadrilateral> &vect,
               string sName,
               int iWid, 
               int iHei) 
{
    // 멤버 값을 파라미터로 전달받아 push_back 
    vect.push_back({ sName, iWid, iHei });
}

// 요소를 출력하는 함수
void printVector(vector<Quadrilateral>& vect) {
    vector<Quadrilateral>::iterator it = vect.begin();

    while (it != vect.end())
    {
        cout << "sName  :" << (*it).sName << endl;
        cout << "iWidth :" << (*it).iWidth << endl;
        cout << "iHeight:" << (*it).iHeight << "\n\n";
        it++;
    }
}

int main()
{
    vector<Quadrilateral> vect;

    // 3가지의 사각형 타입 추가하기
    push_back(vect, "사각형1", 10, 20);
    push_back(vect, "사각형2", 22, 4);
    push_back(vect, "사각형3", 50, 60);

    printVector(vect);
}
```
sName  :사각형1
iWidth :10
iHeight:20

sName  :사각형2
iWidth :22
iHeight:4

sName  :사각형3
iWidth :50
iHeight:60

-> 사각형의 가로, 세로 값을 가진 클래스를 정의하고 vector을 자료형을 해당 클래스로 선언하였다. vector는 클래스 템플릿이기 때문에 클래스 또한 자료형이 된다. pushback을 통하여 vector에 요소를 추가하고 출력한다. 출력시 클래스의 멤버에 접근하려면 -> 이나 (*it).멤버이름 을 통한 접근이 필요하다.
  


## 4. 해당 코드는  size와 capacity의 차이를 아주 간단한 로직으로 확인할 수 있는 코드이다.

```cpp
// 다음 프로그램의 실행 결과를 분석하라.
#include <vector>
#include <iostream>
using namespace std;
int main()
{
	vector<int> v1(5);
	v1.push_back(3);

	cout << v1.capacity() << endl;
	cout << v1.size() << endl;
}
```

결과:
7
6

-> 결과를 통해 5개의 요소가 있는 vector에 pushback 으로 요소 추가시, 사이즈는 1이 늘어나지만 capacity는 메모리가 차지하는 공간을 할당하기 때문에 필요개수보다 더 크게 늘려서 할당한다.

## 5. 4번의 프로그램에서 3 저장되는 위치는?
-> 순서상 6번째, 즉 5번째 인덱스에 저장된다.


## 6. 해당 코드는  vector요소의 값을 수정해보는 아주 간단한 코드이다.

```cpp
// 4의 프로그램에서 첫 번째 위치에 데이터 10을 저장하는 프로그램을 작성하라.
#include <vector>
#include <iostream>
using namespace std;


// 요소를 출력하는 함수
void printVector(vector<int>& vect) {
    vector<int>::iterator it = vect.begin();

    int iCnt = 1;
    while (it != vect.end())
    {
        cout << "sName  " << iCnt << "번쨰 값: " << *it << endl;
        it++;
        iCnt++;
    }
}

int main()
{
	vector<int> v1(5);
	v1.push_back(3);

	cout << v1.capacity() << endl;
	cout << v1.size() << endl;

	v1[0] = 10;

    printVector(v1);
}
```

결과:
7
6
sName  1번쨰 값: 10
sName  2번쨰 값: 0
sName  3번쨰 값: 0
sName  4번쨰 값: 0
sName  5번쨰 값: 0
sName  6번쨰 값: 3



## 7. 해당 코드는 vector의 비교연산자가 어떻게 작동하는지 확인할 수 있는 간단한 코드이다.

```cpp
// 아래의 링크를 참조하여 vector 클래스의 다른 멤버 함수와 연산자를 활용한 프로그램을 작성하라.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> a = { 1, 2, 3 };
    vector<int> b = { 1, 2, 4 };
    vector<int> c = { 1, 2, 3, 0};
    vector<int> d = { 1, 2, 4, 0 };

    cout << "a : { 1, 2, 3 }" << endl;
    cout << "b : { 1, 2, 4 }" << endl;
    cout << "c : { 1, 2, 3, 0 }" << endl;
    cout << "d : { 1, 2, 4, 0 }" << "\n\n";

    cout << "(a == c): " << (a == c) << endl;
    cout << "(a != c): " << (a != c) << endl;
    cout << "(a <  b): " << (a < b) << endl;
    cout << "(b >  a): " << (b > a) << endl;
    cout << "(a <= c): " << (a <= c) << endl;
    cout << "(b >= c): " << (b >= c) << endl;
    cout << "(b >= d): " << (b >= d) << endl;
}
```

결과:
a : { 1, 2, 3 }
b : { 1, 2, 4 }
c : { 1, 2, 3, 0 }
d : { 1, 2, 4, 0 }

(a == c): 0
(a != c): 1
(a <  b): 1
(b >  a): 1
(a <= c): 1
(b >= c): 1
(b >= d): 0

-> 결과를 통해 vector에 동작되는 비교연산자의 개념을 확인할 수 있다.
1. vector의 ==, != 비교연산은 원소개수 + 인덱스 값 + 순서 이 세가지가 같아야 true이다 나머지는 다 false.
2. <, <=, >, >= 연산은 순차적으로 확인한다. -> 앞에서 부터 순서대로 요소 하나씩 비교하다가 다른 값이 있으면 그 값을 비교해서 출력한다. 
3. 길이가 다른 vector 비교시, 앞부분이 같으면 원소개수가 적은 쪽이 더 작다고 판단한다.
4. 값의 합은 비교연산과 상관이 없다. 

