# 프로그램 코드와 설명

## 1. 해당 코드는 Virtual 키워드의 개념과 오버라이딩된 함수를 호출했을 때의 차이를 확인 할 수 있는 코드이다. 

```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void print() {
		cout << "print() in base class" << endl;
	}
	void show() {
		cout << "show() in base class" << endl;
	}
};

class Derived : public Base
{
public:
	void print() {
		cout << "print() in derived class" << endl;
	}
	void show() {
		cout << "show() in derived class" << endl;
	}
};

int main(int argc, char const* argv[])
{
	Base b, * bptr;
	Derived d;

	b.print(); // Base 클래스의 print() 함수 호출
	d.print(); // Derived 클래스의 print() 함수 호출

	bptr = &d;     // Derived의 객체 d를 Base 자료형의 포인터 변수에 저장

	cout << "Base 객체 b의 주소: " << &b << endl;

	bptr->print(); // Base 포인터 변수를 통해 Derived 객체의 print() 함수 호출
	bptr->show();  // Base 포인터 변수를 통해 Base 객체의 show() 함수 호출

	cout << "Derived 객체 d의 주소:" << &d << endl;

		bptr->Base::print();  // Derived 객체를 저정한 포인터를 통한 Base 객체의 print() 함수 호출

	return 0;
}
```
결과:
print() in base class
print() in derived class
Base 객체 b의 주소: 000000DF216FF758
print() in derived class
show() in base class
Derived 객체 d의 주소:000000DF216FF798
print() in base class

-> 결과를 통해 정적 다형성의 예시이며 포인터가 자식 객체를 가르키더라도 show함수에 대해서는 다형성이 적용되지 않는다라는 것을 알 수 있다.


## 2. 해당 코드는 부모 클래스 타입의 객체를 생성할고 소멸할때, 소멸자에 Virtual 키워드를 붙혀야하는 이유를 알 수 있는 코드이다.

```cpp
#include <iostream>
using namespace std;

class Parent {
public:
	Parent() { cout << "Parent 생성자" << endl; }
	virtual ~Parent() { cout << "Parent 소멸자" << endl; }  // Parent의 소멸자가 Child, TestChild의 소멸자와 연계가 필요(virtual)
	 //~Parent() { cout << "Parent 소멸자" << endl; }  // Parent의 소멸자가 Child, TestChild의 소멸자와 연계가 필요(virtual)
};

class Child :public Parent {
public:
	Child() { cout << "Child 생성자" << endl; }
	~Child() { cout << "Child 소멸자" << endl; }
};

class TestChild : public Child {
public:
	TestChild() { cout << "TestChild 생성자" << endl; }
	~TestChild() { cout << "TestChild 소멸자" << endl; }
};

int main() {
	Parent* a = new TestChild;
	delete a;

	//Child b;
	//TestChild c;
}
```
결과:
Parent 생성자
Child 생성자
TestChild 생성자
TestChild 소멸자
Child 소멸자
Parent 소멸자

-> 결과를 통해 부모 소멸자에 virtual키워드가 붙어 생성자와 소멸자가 제대로 호출된것을 볼 수 있다. 만약 virtual키워드가 붙지않은 (주석친 코드) 소멸자를 사용한다면, 객체 a는 부모클래스를 바라보기 때문에, 자식 클래스의 소멸자는 호출되지 않아 메모리 공간이 생겼지만 삭제되지않는 메모리 누수가 발생한다.

만약 a를 child 타입으로 선언한다면, child소멸자에도 virtual키워드를 붙혀야할 것 같지만, 가장 위에 있는 부모 클래스에만 virtual이 붙혀지면, 그 밑에있는 자식 클래스 소멸자는 자동으로 vitual키워드가 붙은 가상 소멸자가 된다.
즉, 자식 클래스에는 virtual을 꼭 붙히지 않아도 된다. 

  
# 과제 외에 프로그램 작성한 것

## 1. 해당 프로그램은 클래스의 멤버 배열 변수에 접근, 반환, 값변경, 원소 값 삭제등 다양한 방법으로 멤버 변수를 핸들링하는 코드 예제이다. 구조는 github내용을 기반으로 작성하였다.

```cpp
#include <iostream>
//#include <vector> 동적 때 사용 가능
using namespace std;
#define ARRVAL 100

class MyArray {
	int buf[ARRVAL];

public:
	MyArray() {
		// 배열 값 초기화
		for (int i = 0; i < ARRVAL; i++) {
			buf[i] = 0;
		}
	}

	// front():첫 번째 원소에 접근 (반환)
	int fornt() {
		return buf[0];
	}

	// back() : 마지막 원소에 접근(반환)
	int back() {
		return buf[size()];
	}

	// size(): 현재 원소 개수 반환
	int size() {
		int iVal = 0;
		for (int i = 0; i < ARRVAL; i++) {
			if (buf[i] != 0) {
				iVal = i;
			}
		}
		// 만약 빈 배열 값이 없으면 제일 마지막 자리를 return
		return iVal;
	}

	// empty(): 배열이 비어 있는지 여부를 boolean(true/false)으로 반환
	bool empty(int iIdx) {

		bool bEmpty = buf[iIdx] == 0 ? true : false;
		return bEmpty;
	}

	// capacity(): 배열 클래스에 할당된 메모리 공간의 크기 반환
	int capacity() {
		return sizeof(buf);
	}

	// at(int idx): idx에 있는 값 반환
	int at(int iIdx) {
		return buf[iIdx];
	}

	bool DelcCheck(int iIdx) {
		bool bCheck = true;

		bCheck = iIdx < 0 ? false : true;
		bCheck = iIdx > capacity() ? false : true;

		return bCheck;
	}

	// insert(int idx, data): idx에 값 저장
	void insert(int iIdx, int iData) {
		buf[iIdx] = iData;
		cout << "insert함수 " << iIdx << "변째 저장소에"
			<< iData << "값 저장" << endl;

	}

	// push_back( data): 배열의 끝에 원소를 추가 -> 배열이 없을때는 0번째의 값
	void push_back(int iData) {
		buf[size()] = iData;
		cout << "push_back함수 " << size() << "변째 저장소에"
			<< iData << "값 저장" << endl;
	}

	// pop_back(); 배열의 마지막 원소를 제거 -> 마지막 값 제거
	void pop_back() {
		buf[size()] = 0;
		cout << "pop_back함수 " << size() << "변째 저장소에"
			<< "0으로 값 변경 변경된 값: " << buf[size()] << endl;
	}

	// 값을 잘 못 입력했을 때 예외처리가 필요함
};

int main() {
	int iVal;
	int iIdx;
	bool bCheck = true;
	MyArray arr;

	cout << "fornt함수 호출: " << arr.fornt() << endl;
	cout << "back함수 호출: " << arr.back() << endl;
	cout << "size함수 호출: " << arr.size() << endl;

	cout << "확인할 배열의 값을 입력해주세요 ";
	cin >> iVal;

	// 인덱스 값으로 변경
	iIdx = iVal - 1;

	// 유효성 체크
	if (!(arr.DelcCheck(iIdx))) {
		cout << "잘못된 입력값입니다. 1부터 100까지를 입력해주세요.";
		return 0;
	}

	cout << "size함수 호출: " << arr.size() << endl;
	cout << "empty함수 호출: " << arr.empty(iIdx) << endl;
	cout << "capacity함수 호출: " << arr.capacity() << endl;
	cout << "at함수 호출: " << arr.at(iIdx) << endl;
	cout << "insert함수 호출" << endl;
	arr.insert(iIdx, 22);

	cout << "size함수 호출: " << arr.size() << endl;

	cout << "push_back함수 호출" << endl;
	arr.push_back(24);
	cout << "pop_back함수 호출" << endl;
	arr.pop_back();
}

```

결과: 
fornt함수 호출: 0
back함수 호출: 0
size함수 호출: 0
확인할 배열의 순서 값을 입력해주세요 4
size함수 호출: 0
empty함수 호출: 1
capacity함수 호출: 400
at함수 호출: 0
insert함수 호출
insert함수 3변째 저장소에22값 저장
size함수 호출: 3
push_back함수 호출
push_back함수 3변째 저장소에24값 저장
pop_back함수 호출
pop_back함수 0변째 저장소에0으로 값 변경 변경된 값: 0

-> 결과를 오류 없이 출력됨. (초반엔 배열에 인덱스 값을 잘못 집어넣어 인덱스가 범위가 벗어나는 실행 오류가 발생하였음.)